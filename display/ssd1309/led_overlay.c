
/* add more diplay options as they are created */
#ifdef LED_OVERLAY

#include <string.h>
#include <stdlib.h>
#include <math.h>
#if defined(DISP_SSD1309)
  #include <ssd1309_driver.h>
  extern uint8_t * framebuf; /* or whatever its called */
//  #define GBUFFER framebuf
  #define FRAMEBUF_P_WIDTH  128
  #define FRAMEBUF_P_HEIGHT 64
  #define FRAMEBUF_PAGES    8
  #define FRAMEBUF_LINES_PER_PG (FRAMEBUF_P_HEIGHT / FRAMEBUF_PAGES)
  #define FRAMEBUF_LEN      (FRAMEBUF_PAGES * FRAMEBUF_P_WIDTH) /* in bytes */
#endif
#include <led_overlay.h>

#define DIGIT_HEIGHT 32
#define DIGIT_PGHGT  (DIGIT_HEIGHT / FRAMEBUF_LINES_PER_PG)
#define DIGIT_WIDTH  17
#define DIGIT_SPACE  2

#define MAX_DIGITS   3
#define MIN_POS      0
#define MAX_X_POS    ((FRAMEBUF_P_WIDTH-1) - (MAX_DIGITS * DIGIT_WIDTH) - ((MAX_DIGITS-2) * DIGIT_SPACE))
#define MAX_Y_POS    ((FRAMEBUF_P_HEIGHT-1) - DIGIT_HEIGHT)

#define MAXVAL_1DIG  9
#define MAXVAL_2DIG  99
#define MAXVAL_3DIG  999
#define MAXVAL_4DIG  9999

#define BLANK_DIGIT_IDX 0xf     /* set this value in ctx.dval[n] to blank digit n */
#define CTX_WMARK    0x4C45444F

#define DIGIT_BUFLEN (DIGIT_PGHGT * DIGIT_WIDTH)

/* digit is blanked */
static const uint8_t bmap_dig_blank[DIGIT_BUFLEN] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; 

static const uint8_t bmap_dig_0[DIGIT_BUFLEN] = {
    0xf8, 0xfc, 0xfa, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xfa, 0xfc, 0xf8, 
    0x3f, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x7f, 0x3f, 
    0xfe, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xfe, 
    0x1f, 0x3f, 0x5f, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x5f, 0x3f, 0x1f };
static const uint8_t bmap_dig_1[DIGIT_BUFLEN] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xfc, 0xf8, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x7f, 0x3f, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xfe, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x3f, 0x1f };
static const uint8_t bmap_dig_2[DIGIT_BUFLEN] = {
    0x00, 0x00, 0x02, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xfa, 0xfc, 0xf8, 
    0x00, 0x00, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xbf, 0x7f, 0x3f, 
    0xfe, 0xff, 0xfe, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
    0x1f, 0x3f, 0x5f, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x40, 0x00, 0x00 };
static const uint8_t bmap_dig_3[DIGIT_BUFLEN] = {
    0x00, 0x00, 0x02, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xfa, 0xfc, 0xf8, 
    0x00, 0x00, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xbf, 0x7f, 0x3f, 
    0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0xff, 0xfe, 
    0x00, 0x00, 0x40, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x5f, 0x3f, 0x1f };
static const uint8_t bmap_dig_4[DIGIT_BUFLEN] = {
    0xf8, 0xfc, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xfc, 0xf8, 
    0x3f, 0x7f, 0xbf, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xbf, 0x7f, 0x3f, 
    0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0xff, 0xfe, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x3f, 0x1f };
static const uint8_t bmap_dig_5[DIGIT_BUFLEN] = {
    0xf8, 0xfc, 0xfa, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x02, 0x00, 0x00, 
    0x3f, 0x7f, 0xbf, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x80, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0xff, 0xfe, 
    0x00, 0x00, 0x40, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x5f, 0x3f, 0x1f };
static const uint8_t bmap_dig_6[DIGIT_BUFLEN] = {
    0xf8, 0xfc, 0xfa, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x02, 0x00, 0x00, 
    0x3f, 0x7f, 0xbf, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x80, 0x00, 0x00, 
    0xfe, 0xff, 0xfe, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0xff, 0xfe, 
    0x1f, 0x3f, 0x5f, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x5f, 0x3f, 0x1f };
static const uint8_t bmap_dig_7[DIGIT_BUFLEN] = {
    0x00, 0x00, 0x02, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xfa, 0xfc, 0xf8, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x7f, 0x3f, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xfe, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x3f, 0x1f };
static const uint8_t bmap_dig_8[DIGIT_BUFLEN] = {
    0xf8, 0xfc, 0xfa, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xfa, 0xfc, 0xf8, 
    0x3f, 0x7f, 0xbf, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xbf, 0x7f, 0x3f, 
    0xfe, 0xff, 0xfe, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0xff, 0xfe, 
    0x1f, 0x3f, 0x5f, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0x5f, 0x3f, 0x1f };
static const uint8_t bmap_dig_9[DIGIT_BUFLEN] = {
    0xf8, 0xfc, 0xfa, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xfa, 0xfc, 0xf8, 
    0x3f, 0x7f, 0xbf, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xbf, 0x7f, 0x3f, 
    0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xfe, 0xff, 0xfe, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x3f, 0x1f };

static const uint8_t * bmaps[] = {
    bmap_dig_blank, /* zero index = blank digit ! */
    bmap_dig_0,
    bmap_dig_1,
    bmap_dig_2,
    bmap_dig_3,
    bmap_dig_4,
    bmap_dig_5,
    bmap_dig_6,
    bmap_dig_7,
    bmap_dig_8,
    bmap_dig_9
};

static uint32_t g_sessionGenerator = 1;

typedef struct led_ctx_type {
    uint32_t watermark;
    uint32_t sessionid;
    uint8_t  xpos;
    uint8_t  ypos;
    uint8_t  diglen;
    uint8_t  autoupdate;
    int32_t  maxvalue;
    uint8_t  dval[MAX_DIGITS]; /* dval[0] is the "ones" digit, far right */
    uint8_t  filler;
} led_ctx_t;

// given a digit index into bmaps[], copy it into the framebuffer GBUFFER[]
// at the indicated pixel location, top-left corner
static void digit_render(uint8_t xpos, uint8_t ypos, uint8_t dig) {
    uint8_t  fb_page  = ypos / FRAMEBUF_LINES_PER_PG;
    uint8_t  n        = ypos % FRAMEBUF_LINES_PER_PG; // line-misalignment in no. of bits. 0 := aligned
    uint8_t  fbmask   = 0xff >> (8 - n); // for retaining existing framebuffer data (shifted digit location)
    uint8_t  fbmasknxt= 0xff << n;       // mask for the next page down, if shifted.
    uint8_t  bmidx    = 0; // index into digit bitmap (0..51)
    uint8_t  digwidth = 0; // prevent a molulo compute by monitoring the X position rel to the width of the digit to find rollover point into the next FB page.
    uint32_t fb_start = (fb_page * FRAMEBUF_P_WIDTH) + xpos; // starting index into FB (by page)
    const uint8_t * bm = (dig == BLANK_DIGIT_IDX) ? bmaps[0] : bmaps[dig+1];
    
    while (bmidx < DIGIT_BUFLEN) {
        framebuf[fb_start] = (framebuf[fb_start] & fbmask) | (bm[bmidx] << n);
        if (n && (fb_start + FRAMEBUF_P_WIDTH) < FRAMEBUF_LEN) {
            // for shifted copies,
            // render remaining part of the display digit into the next page below,
            // as long as it is still within the framebuffer
            framebuf[fb_start+FRAMEBUF_P_WIDTH] = 
                (framebuf[fb_start+FRAMEBUF_P_WIDTH] & fbmasknxt) | (bm[bmidx] >> (8-n));
        }
        fb_start ++;
        bmidx ++;
        digwidth ++;
        if (digwidth >= DIGIT_WIDTH) {
            // re-calulate FB page and index posn for next page
            //fb_page ++;
            fb_start += FRAMEBUF_P_WIDTH;
            digwidth = 0;
        }
    }
}

// given a digit index (0-9,BLANK_DIGIT_IDX) update it in framebuffer GBUFFER[]
// at the indicated pixel location, top-left corner
// Note: this will erase previous bitmap. Use this method to updated the digit.
static void digit_write(uint8_t xpos, uint8_t ypos, uint8_t dig) {
    digit_render(xpos,ypos,BLANK_DIGIT_IDX);
    if (dig < BLANK_DIGIT_IDX)
        digit_render(xpos,ypos,dig);
}

static void fill_digits(uint8_t * dval, uint8_t dcount, uint32_t val) {
    /* index [0] is the least significant digit */
    dcount = (dcount > MAX_DIGITS) ? MAX_DIGITS : dcount;
    if (dval) {
        uint32_t div  = (uint32_t)pow(10,dcount); /* 1,10,100,1000 */
        uint8_t  lblank = 1; /* flag for initial left-J blanking */
        memset(dval, BLANK_DIGIT_IDX, MAX_DIGITS); /* blank all digits to start */
        while (val >= div) {
            val -= div; /* subtract over-value until value can actually be rendered on avail digits */
        }
        while (dcount) {
            div = div / 10;
            dcount --;
            dval[dcount] = val / div;
            val = val - dval[dcount] * div;
            if (lblank && (dval[dcount] == 0)) {
                dval[dcount] = BLANK_DIGIT_IDX; /* blank it */
            } else if (lblank) {
                lblank = 0;
            }
        }
    }
}

void * ledo_open(uint8_t xPos, uint8_t yPos, uint8_t digCount, int initValue, uint8_t onUpdate) {
    led_ctx_t * ctx = 0;
    /* test ranges */
    if ((xPos < MAX_X_POS) && (yPos < MAX_Y_POS) && 
        digCount && (digCount <= MAX_DIGITS)) {
        int32_t  value = 0;
        switch (digCount) {
        case 1:  value = MAXVAL_1DIG; break;
        case 2:  value = MAXVAL_2DIG; break;
        case 3:  
        default: value = MAXVAL_3DIG; break;
        }
        if (initValue > value) {
            initValue = value;
        }
        ctx = (led_ctx_t *)malloc(sizeof(led_ctx_t));
        if (ctx) {
            memset(ctx,0,sizeof(led_ctx_t));
            ctx->watermark = CTX_WMARK; /* "LEDO" */
            ctx->sessionid = g_sessionGenerator ++;
            ctx->xpos = xPos;
            ctx->ypos = yPos;
            ctx->diglen = digCount;
            ctx->autoupdate = (onUpdate)?1:0;
            ctx->maxvalue = value;
            if (initValue < 0) {
                /* setup to have initial blank LED digits (invisible) */
                memset(&(ctx->dval[0]), BLANK_DIGIT_IDX, MAX_DIGITS);
            } else {
                fill_digits(&(ctx->dval[0]), ctx->diglen, initValue);
            }
            /* if auto-refresh then render the display right now */
            if (ctx->autoupdate) {
                ledo_refresh(ctx);
            }
        }
    }
    return (void *)ctx;
}

void ledo_close( void ** ctx) {
    if (ctx) {
        free(*ctx);
        *ctx = 0;
    }
}

int ledo_update(void * _ctx, uint32_t val) {
    int rc = 1;
    if (_ctx) {
        led_ctx_t * ctx = (led_ctx_t *)_ctx;
        if (ctx->watermark == CTX_WMARK) {
            fill_digits(ctx->dval, ctx->diglen, val);
            if (ctx->autoupdate) {
                ledo_refresh(ctx);
            }
            rc = 0; // OK
        }
    }
    return rc;
}

int ledo_refresh(void * _ctx) {
    int rc = 1;
    if (_ctx) {
        led_ctx_t * ctx = (led_ctx_t *)_ctx;
        if (ctx->watermark == CTX_WMARK) {
            // eg. if 3 digits, render dig[2],[1],[0] from left to right
            uint8_t digidx = ctx->diglen;
            uint8_t xposn = ctx->xpos;
            while (digidx) {
                digidx --; // adjust to be an index and run it down to 0
                digit_write(xposn, ctx->ypos, ctx->dval[digidx]);
                xposn += (DIGIT_WIDTH + DIGIT_SPACE);
            }
            rc = 0; // OK
        }
    }
    return rc;
}

#endif /* LED_OVERLAY */
